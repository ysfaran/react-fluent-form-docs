(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{168:function(e,n,r){"use strict";r.r(n),r.d(n,"frontMatter",(function(){return c})),r.d(n,"metadata",(function(){return u})),r.d(n,"rightToc",(function(){return m})),r.d(n,"default",(function(){return d}));var t=r(1),o=r(9),a=r(0),s=r.n(a),i=r(169),l=function(e){var n=e.color,r=void 0===n?"#2f83e9":n,a=Object(o.a)(e,["color"]);return s.a.createElement("span",Object(t.a)({style:{backgroundColor:r,borderRadius:"2px",color:"#fff",padding:"0.2rem"}},a))},c={id:"single-submission-handler",title:"Single Submission Handler",sidebar_label:"Single Submission Handler"},u={id:"recipes/single-submission-handler",title:"Single Submission Handler",description:'import Highlight from "../../src/mdx-components/Highlight";',source:"@site/docs/recipes/single-submission-handler.mdx",permalink:"/react-fluent-form-docs/docs/recipes/single-submission-handler",editUrl:"https://github.com/ysfaran/react-fluent-form-docs/edit/master/docs/recipes/single-submission-handler.mdx",sidebar_label:"Single Submission Handler",sidebar:"someSidebar",previous:{title:"What are Recipes?",permalink:"/react-fluent-form-docs/docs/recipes/what-are-recipes"},next:{title:"Grouping Field Data",permalink:"/react-fluent-form-docs/docs/recipes/grouping-field-data"}},m=[{value:"useMergedSubmit",id:"usemergedsubmit",children:[]},{value:"Example",id:"example",children:[]}],b={rightToc:m};function d(e){var n=e.components,r=Object(o.a)(e,["components"]);return Object(i.b)("wrapper",Object(t.a)({},b,r,{components:n,mdxType:"MDXLayout"}),Object(i.b)("p",null,"Sometimes it's better to seperate your forms, for example if:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"they deal with different concerns"),Object(i.b)("li",{parentName:"ul"},"it should be possible to save them independently"),Object(i.b)("li",{parentName:"ul"},"they are placed inside a wizard")),Object(i.b)("p",null,"In some cases you might have to connect them back together in order to submit all forms at once.\nAs an example you could have multiple forms which can be saved independently and then also a ",Object(i.b)(l,{mdxType:"Highlight"},"Save All")," button, to trigger submission for all forms."),Object(i.b)("h2",{id:"usemergedsubmit"},"useMergedSubmit"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"useMergedSubmit")," is a custom hook, that returns a function which is similar to the ",Object(i.b)("a",Object(t.a)({parentName:"p"},{href:"../api/use-fluent-form#handlesubmit"}),Object(i.b)("inlineCode",{parentName:"a"},"handleSubmit"))," returned by ",Object(i.b)("inlineCode",{parentName:"p"},"useFluentForm"),".\nIt receives any amount of fluent form instances as paramater:"),Object(i.b)("pre",null,Object(i.b)("code",Object(t.a)({parentName:"pre"},{className:"language-ts"}),'import { useCallback, useRef } from "react";\nimport { UseFluentForm } from "react-fluent-form";\n\nexport function useMergedSubmit(...fluentForms: UseFluentForm<any>[]) {\n  const successCallbackRef = useRef<Function>(() => undefined);\n  const failureCallbackRef = useRef<Function>(() => undefined);\n\n  const handleSubmit = useCallback(\n    (\n      success: Function = () => undefined,\n      failure: Function = () => undefined\n    ) => {\n      successCallbackRef.current = success;\n      failureCallbackRef.current = failure;\n\n      return async (e: any) => {\n        if (typeof e === "object") {\n          if (typeof e.preventDefault === "function") {\n            e.preventDefault();\n          }\n          if (typeof e.stopPropagation === "function") {\n            e.stopPropagation();\n          }\n        }\n\n        const submitPromises: Promise<boolean>[] = [];\n\n        for (let i = 0; i < fluentForms.length; i++) {\n          const currentForm = fluentForms[i];\n          const currentPromise = new Promise<boolean>((resolve) => {\n            currentForm.handleSubmit(\n              () => resolve(true),\n              () => resolve(false)\n            )(e);\n          });\n          submitPromises.push(currentPromise);\n        }\n\n        const results: boolean[] = await Promise.all(submitPromises).catch(() =>\n          failure()\n        );\n\n        const successful = results.every((results) => results);\n\n        successful\n          ? successCallbackRef.current()\n          : failureCallbackRef.current();\n      };\n    },\n    [fluentForms]\n  );\n  return handleSubmit;\n}\n')),Object(i.b)("h2",{id:"example"},"Example"),Object(i.b)("p",null,"Following example contains two seperate forms: one for personal details and another for address details.\nThe ",Object(i.b)("inlineCode",{parentName:"p"},"handleSubmit")," function returned by ",Object(i.b)("inlineCode",{parentName:"p"},"useMergedSubmit")," can be called with with a success/failure callback and triggered via e.g. a button click:"),Object(i.b)("pre",null,Object(i.b)("code",Object(t.a)({parentName:"pre"},{className:"language-jsx"}),"const personalForm = useFluentForm(personalConfig);\nconst addressForm = useFluentForm(addressConfig);\n\nconst handleSubmit = useMergedSubmit(\n  personalForm,\n  addressForm\n  /* add any amount of forms */\n);\n\n// will be called if there is no error in every form\nconst handleSubmitSuccess = () => {\n  console.log(personalForm.values);\n  console.log(addressForm.values);\n};\n\n// will be called if there is at least one error in any form\nconst handleSubmitFailure = () => {\n  console.log(personalForm.errors);\n  console.log(addressForm.errors);\n};\n\nreturn (\n  // render forms ...\n  <button onClick={handleSubmit(handleSubmitSuccess, handleSubmitFailure)} />\n);\n")))}d.isMDXComponent=!0},169:function(e,n,r){"use strict";r.d(n,"a",(function(){return m})),r.d(n,"b",(function(){return f}));var t=r(0),o=r.n(t);function a(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function s(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,t)}return r}function i(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?s(Object(r),!0).forEach((function(n){a(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):s(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function l(e,n){if(null==e)return{};var r,t,o=function(e,n){if(null==e)return{};var r,t,o={},a=Object.keys(e);for(t=0;t<a.length;t++)r=a[t],n.indexOf(r)>=0||(o[r]=e[r]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(t=0;t<a.length;t++)r=a[t],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var c=o.a.createContext({}),u=function(e){var n=o.a.useContext(c),r=n;return e&&(r="function"==typeof e?e(n):i({},n,{},e)),r},m=function(e){var n=u(e.components);return o.a.createElement(c.Provider,{value:n},e.children)},b={inlineCode:"code",wrapper:function(e){var n=e.children;return o.a.createElement(o.a.Fragment,{},n)}},d=Object(t.forwardRef)((function(e,n){var r=e.components,t=e.mdxType,a=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=u(r),d=t,f=m["".concat(s,".").concat(d)]||m[d]||b[d]||a;return r?o.a.createElement(f,i({ref:n},c,{components:r})):o.a.createElement(f,i({ref:n},c))}));function f(e,n){var r=arguments,t=n&&n.mdxType;if("string"==typeof e||t){var a=r.length,s=new Array(a);s[0]=d;var i={};for(var l in n)hasOwnProperty.call(n,l)&&(i[l]=n[l]);i.originalType=e,i.mdxType="string"==typeof e?e:t,s[1]=i;for(var c=2;c<a;c++)s[c]=r[c];return o.a.createElement.apply(null,s)}return o.a.createElement.apply(null,r)}d.displayName="MDXCreateElement"}}]);